import { Telegraf, Markup } from 'telegraf';
import * as path from 'path';
import * as fs from 'fs/promises';
import { main as generateContent } from '../index';
import { getNextTopic } from '../topics/utils';
import { generatePrompt } from '../ai/gpt';
import { uploadToYouTube } from '../youtube/upload';
import { generateTTS as synthTTS } from '../ai/tts';
import { mergeAV } from '../media/merge';
import * as dotenv from 'dotenv';
import { generateVideo } from '../ai/luma';
import { exec } from 'child_process';
dotenv.config();

const TG_BOT_TOKEN = process.env.TG_BOT_TOKEN!;
const SHARED_DIR = path.resolve(__dirname, '../../shared');

let lastVideoPath: string | null = null;
let lastAudioPath: string | null = null;

const bot = new Telegraf(TG_BOT_TOKEN!, {
  handlerTimeout: 300_000
});

bot.start(async ctx => {
  await ctx.reply(
    'ğŸ“² This is the control center for AI influencers. What would you like to do?',
    Markup.inlineKeyboard([
      [Markup.button.callback('ğŸ“ Generate prompt', 'promt_gen')],
      [Markup.button.callback('ğŸ”Š Generate audio', 'tts_gen')],
      [Markup.button.callback('ğŸ¬ Generate video', 'video_gen')],
      [Markup.button.callback('ğŸ”€ Merge video + audio', 'merge')],
      [Markup.button.callback('ğŸ“º Upload video on YouTube', 'upload')],
      [Markup.button.callback('ğŸš€ Launch full pipeline', 'full_pipeline')],
      [Markup.button.callback('ğŸ“© Send payment', 'send_payment')],
    ])
  );
});

function runGenerateContentScript(): Promise<{ audio: string; video: string }> {
  return new Promise((resolve, reject) => {
    const scriptPath = path.resolve(__dirname, '../../../contracts/inft/scripts/generate-content-topics.js');
    exec(
      `node "${scriptPath}"`,
      { cwd: path.resolve(__dirname, '../../../') },
      async (error, stdout, stderr) => {
        if (error) {
          reject(`Running script error: ${stderr || error.message}`);
          return;
        }
        try {
          const audioPath = path.resolve(__dirname, '../../../contracts/inft/audio_text.txt');
          const videoPath = path.resolve(__dirname, '../../../contracts/inft/video_description.txt');
          const [audio, video] = await Promise.all([
            fs.readFile(audioPath, 'utf8'),
            fs.readFile(videoPath, 'utf8'),
          ]);
          resolve({ audio, video });
        } catch (e: any) {
          reject('Reading results error: ' + e.message);
        }
      }
    );
  });
}

bot.action('promt_gen', async ctx => {
  try {
    await ctx.answerCbQuery();
  } catch (e) {
    console.log('Callback query already expired, continuing...');
  }
  await ctx.reply('Generation prompt with AI...');
  try {
    const { audio, video } = await runGenerateContentScript();
    
    await ctx.reply('AI Video Description:\n\n' + video);
    await ctx.reply('AI Audio Text:\n\n' + audio);
  } catch (e: any) {
    await ctx.reply('Generation promt Error: ' + e);
  }
});

bot.action('tts_gen', async ctx => {
  await ctx.reply('Generating audio with AI...');
  try {
    const { audio } = await runGenerateContentScript();
    const topic = 'AI_Generated';
    const audioPath = path.resolve(SHARED_DIR, `${topic}.wav`);
    await synthTTS(audio, audioPath);
    lastAudioPath = audioPath;
    await ctx.replyWithAudio({ source: audioPath });
  } catch (e: any) {
    await ctx.reply('TTS generation error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('video_gen', async ctx => {
  await ctx.reply('Generating video with AI...');
  try {
    const { video } = await runGenerateContentScript();
    const topic = 'AI_Generated';
    const videoPath = path.resolve(SHARED_DIR, `${topic}.mp4`);
    await ctx.reply('Generating video... (this may take 1-2 minutes, please wait)');
    await generateVideo(video, videoPath);
    await ctx.replyWithVideo({ source: videoPath });
  } catch (e: any) {
    await ctx.reply('Generation error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('upload', async ctx => {
  try {
    const { video } = await runGenerateContentScript();
    let topic = 'AI Video';
    const topicMatch = video.match(/^Topic: (.+)$/m);
    if (topicMatch) {
      topic = topicMatch[1].trim();
    }
    
    const files = await fs.readdir(SHARED_DIR);
    const stats = await Promise.all(
        files
          .filter(f => f.endsWith('_final.mp4'))
          .map(async f => ({
            file: f,
            mtime: (await fs.stat(path.join(SHARED_DIR, f))).mtimeMs,
          }))
    );

    stats.sort((a, b) => b.mtime - a.mtime);
    
    if (!stats.length) throw new Error('There are no created videos.');
    const filePath = path.join(SHARED_DIR, stats[0].file);
    const ytId = await uploadToYouTube(filePath, topic, 'Autogenerated by AI influencer');
    await ctx.reply('Uploaded on YouTube! https://youtu.be/' + ytId);
  } catch (e: any) {
    await ctx.reply('Downloading error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('merge', async ctx => {
  await ctx.reply('Send me a video file, then an audio file, then press this button again to merge!');
  if (!lastVideoPath || !lastAudioPath) {
    await ctx.reply('Please upload both a video and an audio file to the bot as files.');
    return;
  }
  try {
    const outPath = path.resolve(SHARED_DIR, 'merged_' + Date.now() + '.mp4');
    await mergeAV(lastVideoPath, lastAudioPath, outPath);
    await ctx.replyWithVideo({ source: outPath });
  } catch (e: any) {
    await ctx.reply('Merge error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('full_pipeline', async ctx => {
  try {
    await ctx.answerCbQuery();
  } catch (e) {
    console.log('Callback query already expired, continuing...');
  }
  await ctx.reply('ğŸš€ Starting full pipeline...');
  try {
    const { audio, video } = await runGenerateContentScript();
    let topic = 'AI Video';
    const topicMatch = video.match(/^Topic: (.+)$/m);
    if (topicMatch) {
      topic = topicMatch[1].trim();
    }
    await ctx.reply('Topic: ' + topic);
    
    await ctx.reply('AI Video Description:\n\n' + video);
    await ctx.reply('AI Audio Text:\n\n' + audio);

    const videoPath = path.resolve(SHARED_DIR, `${topic.replace(/[^a-z0-9]/gi, '_')}.mp4`);
    await ctx.reply('Generating video... (this may take 1-2 minutes, please wait)');
    await generateVideo(video, videoPath);
    await ctx.reply('Video generated:');
    await ctx.replyWithVideo({ source: videoPath });

    const ttsPath = path.resolve(SHARED_DIR, `${topic.replace(/[^a-z0-9]/gi, '_')}.wav`);
    await ctx.reply('Generating audio...');
    await synthTTS(audio, ttsPath);
    await ctx.reply('Audio generated (AI):');
    await ctx.replyWithAudio({ source: ttsPath });

    const outFile = path.resolve(SHARED_DIR, `${topic.replace(/[^a-z0-9]/gi, '_')}_final.mp4`);
    await ctx.reply('Merging video and audio...');
    await mergeAV(videoPath, ttsPath, outFile);
    await ctx.reply('Merged video:');
    await ctx.replyWithVideo({ source: outFile });

    await ctx.reply('Uploading to YouTube...');
    const ytId = await uploadToYouTube(outFile, topic, 'Autogenerated by AI influencer');
    await ctx.reply('Uploaded to YouTube! https://youtu.be/' + ytId);
  } catch (e) {
    await ctx.reply('Pipeline error: ' + (e.message || e.toString()));
  }
});

bot.on('video', async ctx => {
  const fileId = ctx.message.video.file_id;
  const link = await ctx.telegram.getFileLink(fileId);
  const videoPath = path.resolve(SHARED_DIR, 'uploaded_video_' + Date.now() + '.mp4');
  const res = await fetch(link.href);
  const buf = Buffer.from(await res.arrayBuffer());
  await fs.writeFile(videoPath, buf);
  lastVideoPath = videoPath;
  await ctx.reply('Video uploaded!');
});

bot.on('voice', async ctx => {
  const file = ctx.message.voice;
  const fileId = file.file_id;
  const link = await ctx.telegram.getFileLink(fileId);
  const audioPath = path.resolve(SHARED_DIR, 'uploaded_audio_' + Date.now() + '.wav');
  const res = await fetch(link.href);
  const buf = Buffer.from(await res.arrayBuffer());
  await fs.writeFile(audioPath, buf);
  lastAudioPath = audioPath;
  await ctx.reply('Audio uploaded!');
});

bot.on('audio', async ctx => {
  const file = ctx.message.audio;
  const fileId = file.file_id;
  const link = await ctx.telegram.getFileLink(fileId);
  const audioPath = path.resolve(SHARED_DIR, 'uploaded_audio_' + Date.now() + '.wav');
  const res = await fetch(link.href);
  const buf = Buffer.from(await res.arrayBuffer());
  await fs.writeFile(audioPath, buf);
  lastAudioPath = audioPath;
  await ctx.reply('Audio uploaded!');
});

bot.action('send_payment', async ctx => {
  try {
    await ctx.answerCbQuery();
  } catch (e) {
    console.log('Callback query already expired, continuing...');
  }
  await ctx.reply('New payment was detected for AI-naturalist');
  try {
    const { 
      message, 
      from, 
      to, 
      amount,
      contractAddress
    } = await runSendPayment();
    
    const transactionInfo = `ğŸ’° **Payment Transaction Details**

    ğŸ“ **Message:** ${message}

    ğŸ‘¤ **From:** \`${from}\`
    ğŸ‘¥ **To:** \`${to}\`
    ğŸ’ **Amount:** ${amount}

    ğŸŒ **Explorer:** https://chainscan-galileo.0g.ai/address/${contractAddress}`;
    
    await ctx.reply(transactionInfo, { parse_mode: 'Markdown' });
  } catch (e: any) {
    await ctx.reply('Payment processing error: ' + e);
  }

  await new Promise(r => setTimeout(r, 3000));
  await ctx.reply('ğŸ—‚ Topic logged. Contribution registered â€” content roadmap updated accordingly.');

});

function runSendPayment(): Promise<{ 
  message: string; 
  from: string; 
  to: string; 
  amount: string; 
  contractAddress: string; 
}> {
  return new Promise((resolve, reject) => {
    const scriptPath = path.resolve(__dirname, '../../../contracts/inft/scripts/add-last-payment-to-top.js');
    exec(
      `node "${scriptPath}"`,
      { cwd: path.resolve(__dirname, '../../../') },
      async (error, stdout, stderr) => {
        if (error) {
          reject(`Running script error: ${stderr || error.message}`);
          return;
        }
        try {
          const lines = stdout.split('\n');
          let message = '';
          let from = '';
          let to = '';
          let amount = '';
          let contractAddress = '';
          
          for (const line of lines) {
            const trimmedLine = line.trim();
            
            if (trimmedLine.includes('From:') && !trimmedLine.includes('From payment:')) {
              from = trimmedLine.split('From:')[1]?.trim() || '';
            } else if (trimmedLine.includes('To:') && !trimmedLine.includes('To payment:')) {
              to = trimmedLine.split('To:')[1]?.trim() || '';
            } else if (trimmedLine.includes('Amount:') && !trimmedLine.includes('Total volume:')) {
              amount = trimmedLine.split('Amount:')[1]?.trim() || '';
            } else if (trimmedLine.includes('Message:') && !trimmedLine.includes('Message from payment:')) {
              message = trimmedLine.split('Message:')[1]?.trim() || '';
            } else if (trimmedLine.includes('Contract address:') && !trimmedLine.includes('Contract address:')) {
              contractAddress = trimmedLine.split('Contract address:')[1]?.trim() || '';
            }
          }
          
          if (!message) {
            reject('Could not extract message from script output');
            return;
          }
          
          if (!contractAddress) {
            contractAddress = '0xd3d4c6b01059586aCa7EBdd5827Eb020896Bc1A4';
          }
          
          resolve({ 
            message, 
            from, 
            to, 
            amount,
            contractAddress
          });
        } catch (e: any) {
          reject('Transaction data extraction error: ' + e.message);
        }
      }
    );
  });
}

function runSendNewPayment(): Promise<{ 
  from: string; 
  to: string; 
  amount: string; 
  message: string; 
  txHash: string; 
}> {
  return new Promise((resolve, reject) => {
    const scriptPath = path.resolve(__dirname, '../../../contracts/inft/scripts/send-payment.js');
    exec(
      `node "${scriptPath}"`,
      { cwd: path.resolve(__dirname, '../../../') },
      async (error, stdout, stderr) => {
        if (error) {
          reject(`Running send-payment script error: ${stderr || error.message}`);
          return;
        }
        try {
          const lines = stdout.split('\n');
          let from = '';
          let to = '';
          let amount = '';
          let message = '';
          let txHash = '';
          
          for (const line of lines) {
            const trimmedLine = line.trim();
            
            if (trimmedLine.includes('From:') && !trimmedLine.includes('From payment:')) {
              from = trimmedLine.split('From:')[1]?.trim() || '';
            } else if (trimmedLine.includes('To:') && !trimmedLine.includes('To payment:')) {
              to = trimmedLine.split('To:')[1]?.trim() || '';
            } else if (trimmedLine.includes('Amount:') && !trimmedLine.includes('Total volume:')) {
              amount = trimmedLine.split('Amount:')[1]?.trim() || '';
            } else if (trimmedLine.includes('Message:') && !trimmedLine.includes('Message from payment:')) {
              message = trimmedLine.split('Message:')[1]?.trim() || '';
            } else if (trimmedLine.includes('Transaction hash:') && !trimmedLine.includes('Transaction hash:')) {
              txHash = trimmedLine.split('Transaction hash:')[1]?.trim() || '';
            }
          }
          
          if (!txHash) {
            reject('Could not extract transaction hash from script output');
            return;
          }
          
          resolve({ 
            from, 
            to, 
            amount, 
            message, 
            txHash 
          });
        } catch (e: any) {
          reject('New payment data extraction error: ' + e.message);
        }
      }
    );
  });
}

export function launchBot() {
  bot.launch();
  console.log('Telegram-bot launched!');
}