import { Telegraf, Markup } from 'telegraf';
import * as path from 'path';
import * as fs from 'fs/promises';
import { main as generateContent } from '../index';
import { getNextTopic } from '../topics/utils';
import { generatePrompt } from '../ai/gpt';
import { uploadToYouTube } from '../youtube/upload';
import { generateTTS as synthTTS } from '../ai/tts';
import { mergeAV } from '../media/merge';
import * as dotenv from 'dotenv';
import { generateVideo } from '../ai/luma';
import { exec } from 'child_process';
dotenv.config();

const TG_BOT_TOKEN = process.env.TG_BOT_TOKEN!;
const SHARED_DIR = path.resolve(__dirname, '../../shared');

let lastVideoPath: string | null = null;
let lastAudioPath: string | null = null;

const bot = new Telegraf(TG_BOT_TOKEN!, {
  handlerTimeout: 300_000
});

bot.start(async ctx => {
  await ctx.reply(
    'ğŸ¤– I am AI-Influencer. What do you want?',
    Markup.inlineKeyboard([
      [Markup.button.callback('ğŸ“ Generate prompt', 'promt_gen')],
      [Markup.button.callback('ğŸ”Š Generate audio', 'tts_gen')],
      [Markup.button.callback('ğŸ¬ Generate video', 'video_gen')],
      [Markup.button.callback('ğŸ”€ Merge video + audio', 'merge')],
      [Markup.button.callback('â¬†ï¸ Upload last video on YouTube', 'upload')],
      [Markup.button.callback('ğŸš€ Full pipeline', 'full_pipeline')]
    ])
  );
});

function runGenerateContentScript(): Promise<{ audio: string; video: string }> {
  return new Promise((resolve, reject) => {
    const scriptPath = path.resolve(__dirname, '../../../contracts/inft/scripts/generate-content-topics.js');
    exec(
      `node "${scriptPath}"`,
      { cwd: path.resolve(__dirname, '../../../') },
      async (error, stdout, stderr) => {
        if (error) {
          reject(`Running script error: ${stderr || error.message}`);
          return;
        }
        try {
          const audioPath = path.resolve(__dirname, '../../../contracts/inft/audio_text.txt');
          const videoPath = path.resolve(__dirname, '../../../contracts/inft/video_description.txt');
          const [audio, video] = await Promise.all([
            fs.readFile(audioPath, 'utf8'),
            fs.readFile(videoPath, 'utf8'),
          ]);
          resolve({ audio, video });
        } catch (e: any) {
          reject('Reading results error: ' + e.message);
        }
      }
    );
  });
}

bot.action('promt_gen', async ctx => {
  try {
    await ctx.answerCbQuery();
  } catch (e) {
    console.log('Callback query already expired, continuing...');
  }
  await ctx.reply('Generation prompt with AI...');
  try {
    const { audio, video } = await runGenerateContentScript();
    
    await ctx.reply('AI Video Description:\n\n' + video);
    await ctx.reply('AI Audio Text:\n\n' + audio);
  } catch (e: any) {
    await ctx.reply('Generation promt Error: ' + e);
  }
});

bot.action('tts_gen', async ctx => {
  await ctx.reply('Generating audio with AI...');
  try {
    const { audio } = await runGenerateContentScript();
    const topic = 'AI_Generated';
    const audioPath = path.resolve(SHARED_DIR, `${topic}.wav`);
    await synthTTS(audio, audioPath);
    lastAudioPath = audioPath;
    await ctx.replyWithAudio({ source: audioPath });
  } catch (e: any) {
    await ctx.reply('TTS generation error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('video_gen', async ctx => {
  await ctx.reply('Generating video with AI...');
  try {
    const { video } = await runGenerateContentScript();
    const topic = 'AI_Generated';
    const videoPath = path.resolve(SHARED_DIR, `${topic}.mp4`);
    await ctx.reply('Generating video... (this may take 1-2 minutes, please wait)');
    await generateVideo(video, videoPath);
    await ctx.replyWithVideo({ source: videoPath });
  } catch (e: any) {
    await ctx.reply('Generation error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('upload', async ctx => {
  try {
    const { video } = await runGenerateContentScript();
    let topic = 'AI Video';
    const topicMatch = video.match(/^Topic: (.+)$/m);
    if (topicMatch) {
      topic = topicMatch[1].trim();
    }
    
    const files = await fs.readdir(SHARED_DIR);
    const stats = await Promise.all(
        files
          .filter(f => f.endsWith('_final.mp4'))
          .map(async f => ({
            file: f,
            mtime: (await fs.stat(path.join(SHARED_DIR, f))).mtimeMs,
          }))
    );

    stats.sort((a, b) => b.mtime - a.mtime);
    
    if (!stats.length) throw new Error('There are no created videos.');
    const filePath = path.join(SHARED_DIR, stats[0].file);
    const ytId = await uploadToYouTube(filePath, topic, 'Autogenerated by AI influencer');
    await ctx.reply('Uploaded on YouTube! https://youtu.be/' + ytId);
  } catch (e: any) {
    await ctx.reply('Downloading error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('merge', async ctx => {
  await ctx.reply('Send me a video file, then an audio file, then press this button again to merge!');
  if (!lastVideoPath || !lastAudioPath) {
    await ctx.reply('Please upload both a video and an audio file to the bot as files.');
    return;
  }
  try {
    const outPath = path.resolve(SHARED_DIR, 'merged_' + Date.now() + '.mp4');
    await mergeAV(lastVideoPath, lastAudioPath, outPath);
    await ctx.replyWithVideo({ source: outPath });
  } catch (e: any) {
    await ctx.reply('Merge error: ' + e.message);
  }
  await ctx.answerCbQuery();
});

bot.action('full_pipeline', async ctx => {
  try {
    await ctx.answerCbQuery();
  } catch (e) {
    console.log('Callback query already expired, continuing...');
  }
  await ctx.reply('ğŸš€ Starting full pipeline...');
  try {
    const { audio, video } = await runGenerateContentScript();
    let topic = 'AI Video';
    const topicMatch = video.match(/^Topic: (.+)$/m);
    if (topicMatch) {
      topic = topicMatch[1].trim();
    }
    await ctx.reply('Topic: ' + topic);
    
    await ctx.reply('AI Video Description:\n\n' + video);
    await ctx.reply('AI Audio Text:\n\n' + audio);

    const videoPath = path.resolve(SHARED_DIR, `${topic.replace(/[^a-z0-9]/gi, '_')}.mp4`);
    await ctx.reply('Generating video... (this may take 1-2 minutes, please wait)');
    await generateVideo(video, videoPath);
    await ctx.reply('Video generated:');
    await ctx.replyWithVideo({ source: videoPath });

    const ttsPath = path.resolve(SHARED_DIR, `${topic.replace(/[^a-z0-9]/gi, '_')}.wav`);
    await ctx.reply('Generating audio...');
    await synthTTS(audio, ttsPath);
    await ctx.reply('Audio generated (AI):');
    await ctx.replyWithAudio({ source: ttsPath });

    const outFile = path.resolve(SHARED_DIR, `${topic.replace(/[^a-z0-9]/gi, '_')}_final.mp4`);
    await ctx.reply('Merging video and audio...');
    await mergeAV(videoPath, ttsPath, outFile);
    await ctx.reply('Merged video:');
    await ctx.replyWithVideo({ source: outFile });

    await ctx.reply('Uploading to YouTube...');
    const ytId = await uploadToYouTube(outFile, topic, 'Autogenerated by AI influencer');
    await ctx.reply('Uploaded to YouTube! https://youtu.be/' + ytId);
  } catch (e) {
    await ctx.reply('Pipeline error: ' + (e.message || e.toString()));
  }
});

bot.on('video', async ctx => {
  const fileId = ctx.message.video.file_id;
  const link = await ctx.telegram.getFileLink(fileId);
  const videoPath = path.resolve(SHARED_DIR, 'uploaded_video_' + Date.now() + '.mp4');
  const res = await fetch(link.href);
  const buf = Buffer.from(await res.arrayBuffer());
  await fs.writeFile(videoPath, buf);
  lastVideoPath = videoPath;
  await ctx.reply('Video uploaded!');
});

bot.on('voice', async ctx => {
  const file = ctx.message.voice;
  const fileId = file.file_id;
  const link = await ctx.telegram.getFileLink(fileId);
  const audioPath = path.resolve(SHARED_DIR, 'uploaded_audio_' + Date.now() + '.wav');
  const res = await fetch(link.href);
  const buf = Buffer.from(await res.arrayBuffer());
  await fs.writeFile(audioPath, buf);
  lastAudioPath = audioPath;
  await ctx.reply('Audio uploaded!');
});

bot.on('audio', async ctx => {
  const file = ctx.message.audio;
  const fileId = file.file_id;
  const link = await ctx.telegram.getFileLink(fileId);
  const audioPath = path.resolve(SHARED_DIR, 'uploaded_audio_' + Date.now() + '.wav');
  const res = await fetch(link.href);
  const buf = Buffer.from(await res.arrayBuffer());
  await fs.writeFile(audioPath, buf);
  lastAudioPath = audioPath;
  await ctx.reply('Audio uploaded!');
});

export function launchBot() {
  bot.launch();
  console.log('Telegram-bot launched!');
}